
## 지연 로딩과 즉시 로딩

## 페치 계획, 페치 전략, 페치 프로파일

### 페치 계획
하이버네이트에서 로드하는 것들은 페치 계획에 따라 달라짐.
로드해야 하는 객체 네트워크의 하위 그래프를 정의

#### 기본 페치 계획
지연 로딩(FetchType.LAZY), 즉시 로딩(FetchType.EAGER)이 있다.
이 계획은 영속성 도메인 모델 클래스와 관련된 모든 연산에 적용되는 기본 설정이다.
식별자로 엔티티 인스턴스를 로드할 때, 그리고 연관관계를 기반으로 하거나 영속성 컬렉션을 순회해서 엔티티 그래프를 탐색할 때 항상 활성화된다.

> 기본적으로 지연로딩을 기본 페치 계획으로 적용한다.

#### 지연 로딩(FetchType.LAZY)
- FetchType.LAZY를 매핑하면 하이버네이트는 접근하고 있는 데이터만 로드한다.
- 지연 로딩을 구현하기 위해 하이버네이트는 ``Proxy``라는 런타임에 생성되는 엔티티 위치 표시자와 컬렉션용 ``스마트 래퍼``를 사용한다.
- ``@OneToMany, @ManyToMany``: 지연 로딩이 기본 값.


**``Proxy``**
- 런타임에 생성된 엔티티의 하위 클래스의 인스턴스이다.
- Proxy가 나타내는 엔티티 인스턴스의 식별자 값을 가지고 있다.(대체)
- 식별자 조회 외의 메서드가 호출되면 프락스 초기화가 발생하고 데이터 베이스를 호출한다.
  ```java
    // sql select 발생.
    item.getName();
  ```

#### Test -> 실습 코드


**``컬렉션 래퍼(Collection Wrapper)``**
- 컬렉션(Collection)의 경우 ``컬렉션 래퍼(Collection Wrapper)``를 통해 지연 로딩을 구현한다.
```java
...
// 지연 로딩 시, Hash Set이 아닌 PersistentSet(org.hibernate.collection.internal.PersistentSet)으로 대체됨.
private Set<Bid> bids = new HashSet<>();
...
```
- 컬렉션 매핑을 통해 편의 메서드를 제공한다.
```java
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.LazyCollection(
    org.hibernate.annotations.LazyCollectionOption.EXTRA
)
public Set<Bid> getBids() {
    return bids;
}
```
  - ``LazyCollectionOption.EXTRA`을 이용하면 프로퍼티 컬렉션을 초기화(로드) 하지 않는 연산을 지원한다.
```java
    Item item = em.find(Item.class, ITEM_ID);
    // select * from ITEM where ID = ?

    assertEquals(3, item.getBids().size());
    // select count(b) from BID b where b.ITEM_ID = ?
    // -> 프로퍼티 컬렉션을 로드하지 않고, Count 함수를 사용한 연산 쿼리
```  







#### 즉시 로딩(FetchType.EAGER)
- 특정 엔티티 연관관계나 컬렉션을 항상 로드하고 싶을 때 사용한다.
- 한 번 조회 후 다시 DB를 접근하지 않고, 데이터를 메모리 상에서 사용할 경우
  - ex) 지연 로딩의 경우, User를 조회하고 영속성 컨텍스트가 닫힌 경우, User의 프로퍼티인 UserProfile은 초기화되지 않은 프록시이다. -> LazyInitializationException 발생!
> 항상 로드되는 경우 페치 계획을 지연 페치가 아닌 즉시 페치로 변경해야 한다.

##### Test
```java
    Item item = em.find(Item.class, ITEM_ID);
    // 즉시 페치이므로 연관 관계 join 조회
    // select i.*, u.*, b.*
    //  from ITEM i 
    //   left outer join USERS u on u.ID = i.SELLER_ID
    //   left outer join BID b on b.ITEM_ID = i.ID
    //  where i.ID = ?

    em.detach(item); // 준영속화로 인해 지연 로딩이 발생하지 않음.

    // 페치 계획이 즉시 페치이므로, 활용 가능
    assertEquals(3, item.getBids().size());
    assertNotNull(item.getBids().iterator().next().getAmount());

    // 페치 계획이 즉시 페치이므로, 활용 가능
    assertEquals("johndoe", item.getSeller().getUsername());

```




### 페치 전략
엔티티 인스턴스를 로드하려면 관련 테이블 수와 적용된 **페치 전략**에 따라 하나 이상의 SELECT가 실행된다.


### N + 1 문제
기본 페치 계획을 지연 로딩으로 설정했을 때 발생할 수 있다.
모든 items를 순회하면서 각 User를 조회하려면 추가적인 SELECT가 필요하다.
즉, item 하나에 대한 쿼리에 특정 사용자를 조회하는 추가 쿼리가 발생한다.
이를 N + 1 문제라고 한다.

**example**
```java
List<Item> items = em.createQuery("select i from Item i", Item.class).getResultList();
// select * from ITEM

// 1 + N
for (Item item : items) {
    assertNotNull(item.getSeller().getUsername());
    // select * from USERS where ID = ?
}
```
item의 seller에 접근할 것이라는 것을 알고 있다면, 이는 비효율적인 동작이다.
이 같은 경우 ``FetchType.EAGER``로 연관관계를 매핑하면 된다.

```java

// 페치 계획을 EAGER로 매핑하였을 경우
item = em.find(Item.class, ITEM_ID)
// select i.*, u.*
// from ITEM i left outer join USERS u on u.ID = i.SELLER_ID (Join Query 발생 !!)
// where i.ID = ?

```



### 데카르트 곱 문제
다음은 기본 페치 전략을 EAGER로 설정했을 때 발생할 수 있다.


```java

// 페치 계획을 EAGER로 매핑하였을 경우
item = em.find(Item.class, ITEM_ID)
// select i.*, u.*
// from ITEM i left outer join USERS u on u.ID = i.SELLER_ID (Join Query 발생 !!)
// where i.ID = ?

```
위 처럼 EAGER를 기본 전략으로 페치하는 것은 ``@ManyToOne, @OneToOne``에서는 문제가 발생하지 않는다.
하지만  JPA는 특정 시점에 즉시 로딩을 중단해야한다. ex) Item < User < UserProfile...
 ``hibernate.max_fetch_depth`` 전역 프로퍼티로 JOIN depth에 제약을 줄 수 있다.


#### EAGER(즉시 로딩)의 문제점
JOIN을 사용해 컬렉션을 즉시 로드하면 심각한 성능 문제가 발생할 수 있다.

```java
@Entity 
public class Item {
  ...
  @OneToMany(mappedBy = "item", fetch = FetchType.EAGER)
  private Set<Bid> bids = new HashSet<>();

  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "IMAGE")
  @Column(name = "FILENAME")
  private Set<String> images = new HashSet<>();
  ...
}
Item item = em.find(Item.class, ITEM_ID);
// select i.*, b.*, img.*
//  from ITEM i
//   left outer join BID b on b.ITEM_ID = i.ID
//   left outer join IMAGE img on img.ITEM_ID = i.ID
//  where i.ID = ?
// 1 * N * M

em.detach(item);

assertEquals(3, item.getImages().size());
assertEquals(3, item.getBids().size());

```
위 처럼 SQL Join 연산자로 두개 이상의 컬렉션을 페치하면 문제가 발생한다.

|i.ID|i.NAME|...|b.ID|b.AMOUNT|img.FILENAME|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|100.00|foo.jpg|
|1|One|...|1|100.00|foo.jpg|
|1|One|...|1|100.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|foo.jpg|





### 페치 프로파일
페치 계획과 페치 전략을 페치 프로파일로 저장해서 재사용 할 수 있다.







## SQL 실행 최적화