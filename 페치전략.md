# 페치 계획, 페치 전략, 페치 프로파일

## 페치 계획 -> 어떤 데이터를 로드해야 하는지
하이버네이트에서 로드하는 것들은 페치 계획에 따라 달라짐.
로드해야 하는 객체 네트워크의 하위 그래프를 정의

### 기본 페치 계획
지연 로딩(FetchType.LAZY), 즉시 로딩(FetchType.EAGER)이 있다.
이 계획은 영속성 도메인 모델 클래스와 관련된 모든 연산에 적용되는 기본 설정이다.
식별자로 엔티티 인스턴스를 로드할 때, 그리고 연관관계를 기반으로 하거나 영속성 컬렉션을 순회해서 엔티티 그래프를 탐색할 때 항상 활성화된다.

> 기본적으로 지연로딩을 기본 페치 계획으로 적용한다.

#### 지연 로딩(FetchType.LAZY)
- FetchType.LAZY를 매핑하면 하이버네이트는 접근하고 있는 데이터만 로드한다.
- 지연 로딩을 구현하기 위해 하이버네이트는 ``Proxy``라는 런타임에 생성되는 엔티티 위치 표시자와 컬렉션용 ``스마트 래퍼``를 사용한다.
- ``@OneToMany, @ManyToMany``: 지연 로딩이 기본 값.


**``Proxy``**
- 런타임에 생성된 엔티티의 하위 클래스의 인스턴스이다.
- Proxy가 나타내는 엔티티 인스턴스의 식별자 값을 가지고 있다.(대체)
- 식별자 조회 외의 메서드가 호출되면 프락스 초기화가 발생하고 데이터 베이스를 호출한다.
  ```java
    // sql select 발생.
    item.getName();
  ```

##### Test -> 실습 코드


**``컬렉션 래퍼(Collection Wrapper)``**
- 컬렉션(Collection)의 경우 ``컬렉션 래퍼(Collection Wrapper)``를 통해 지연 로딩을 구현한다.
```java
...
// 지연 로딩 시, Hash Set이 아닌 PersistentSet(org.hibernate.collection.internal.PersistentSet)으로 대체됨.
private Set<Bid> bids = new HashSet<>();
...
```
- 컬렉션 매핑을 통해 편의 메서드를 제공한다.
```java
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.LazyCollection(
    org.hibernate.annotations.LazyCollectionOption.EXTRA
)
public Set<Bid> getBids() {
    return bids;
}
```
  - ``LazyCollectionOption.EXTRA`을 이용하면 프로퍼티 컬렉션을 초기화(로드) 하지 않는 연산을 지원한다.
```java
    Item item = em.find(Item.class, ITEM_ID);
    // select * from ITEM where ID = ?

    assertEquals(3, item.getBids().size());
    // select count(b) from BID b where b.ITEM_ID = ?
    // -> 프로퍼티 컬렉션을 로드하지 않고, Count 함수를 사용한 연산 쿼리
```  


#### 즉시 로딩(FetchType.EAGER)
- 특정 엔티티 연관관계나 컬렉션을 항상 로드하고 싶을 때 사용한다.
- 한 번 조회 후 다시 DB를 접근하지 않고, 데이터를 메모리 상에서 사용할 경우
  - ex) 지연 로딩의 경우, User를 조회하고 영속성 컨텍스트가 닫힌 경우, User의 프로퍼티인 UserProfile은 초기화되지 않은 프록시이다. -> LazyInitializationException 발생!
> 항상 로드되는 경우 페치 계획을 지연 페치가 아닌 즉시 페치로 변경해야 한다.

##### Test
```java
    Item item = em.find(Item.class, ITEM_ID);
    // 즉시 페치이므로 연관 관계 join 조회
    // select i.*, u.*, b.*
    //  from ITEM i 
    //   left outer join USERS u on u.ID = i.SELLER_ID
    //   left outer join BID b on b.ITEM_ID = i.ID
    //  where i.ID = ?

    em.detach(item); // 준영속화로 인해 지연 로딩이 발생하지 않음.

    // 페치 계획이 즉시 페치이므로, 활용 가능
    assertEquals(3, item.getBids().size());
    assertNotNull(item.getBids().iterator().next().getAmount());

    // 페치 계획이 즉시 페치이므로, 활용 가능
    assertEquals("johndoe", item.getSeller().getUsername());

```




### 페치 전략 -> 데이터를 어떻게 로드해야 하는지
엔티티 인스턴스를 로드하려면 관련 테이블 수와 적용된 **페치 전략**에 따라 하나 이상의 SELECT가 실행된다.


### N + 1 문제
기본 페치 계획을 지연 로딩으로 설정했을 때 발생할 수 있다.
모든 items를 순회하면서 각 User를 조회하려면 추가적인 SELECT가 필요하다.
즉, item 하나에 대한 쿼리에 특정 사용자를 조회하는 추가 쿼리가 발생한다.
이를 N + 1 문제라고 한다.

**example**
```java
List<Item> items = em.createQuery("select i from Item i", Item.class).getResultList();
// select * from ITEM

// 1 + N
for (Item item : items) {
    assertNotNull(item.getSeller().getUsername());
    // select * from USERS where ID = ?
}
```
item의 seller에 접근할 것이라는 것을 알고 있다면, 이는 비효율적인 동작이다.
이 같은 경우 ``FetchType.EAGER``로 연관관계를 매핑하면 된다.

```java

// 페치 계획을 EAGER로 매핑하였을 경우
item = em.find(Item.class, ITEM_ID)
// select i.*, u.*
// from ITEM i left outer join USERS u on u.ID = i.SELLER_ID (Join Query 발생 !!)
// where i.ID = ?

```



### 데카르트 곱 문제
다음은 기본 페치 전략을 EAGER로 설정했을 때 발생할 수 있다.


```java

// 페치 계획을 EAGER로 매핑하였을 경우
item = em.find(Item.class, ITEM_ID)
// select i.*, u.*
// from ITEM i left outer join USERS u on u.ID = i.SELLER_ID (Join Query 발생 !!)
// where i.ID = ?

```
위 처럼 EAGER를 기본 전략으로 페치하는 것은 ``@ManyToOne, @OneToOne``에서는 문제가 발생하지 않는다.
하지만  JPA는 특정 시점에 즉시 로딩을 중단해야한다. ex) Item < User < UserProfile...
 ``hibernate.max_fetch_depth`` 전역 프로퍼티로 JOIN depth에 제약을 줄 수 있다.


#### EAGER(즉시 로딩)의 문제점
JOIN을 사용해 컬렉션을 즉시 로드하면 심각한 성능 문제가 발생할 수 있다.

```java
@Entity 
public class Item {
  ...
  @OneToMany(mappedBy = "item", fetch = FetchType.EAGER)
  private Set<Bid> bids = new HashSet<>();

  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "IMAGE")
  @Column(name = "FILENAME")
  private Set<String> images = new HashSet<>();
  ...
}
Item item = em.find(Item.class, ITEM_ID);
// select i.*, b.*, img.*
//  from ITEM i
//   left outer join BID b on b.ITEM_ID = i.ID
//   left outer join IMAGE img on img.ITEM_ID = i.ID
//  where i.ID = ?
// 1 * N * M

em.detach(item);

assertEquals(3, item.getImages().size());
assertEquals(3, item.getBids().size());

```
위 처럼 SQL Join 연산자로 두개 이상의 컬렉션을 페치하면 문제가 발생한다.

**i(item) = 1, b(Bid) = 3, img(Image) = 3 일때**
**item이 1개 이고 item 1개에에 포함되는 Bid가 3개이고 Bid 1개에 포함된 Image가 3개일 때 => 1 * 3 * 3**
|i.ID|i.NAME|...|b.ID|b.AMOUNT|img.FILENAME|
|---|---|---|---|---|---|
|1|One|...|1|99.00|foo.jpg|
|1|One|...|1|99.00|bar.jpg|
|1|One|...|1|99.00|baz.jpg|
|1|One|...|2|100.00|foo.jpg|
|1|One|...|2|100.00|bar.jpg|
|1|One|...|2|100.00|baz.jpg|
|1|One|...|3|101.00|foo.jpg|
|1|One|...|3|101.00|bar.jpg|
|1|One|...|3|101.00|baz.jpg|

->

|i.ID|i.NAME|...|b.ID|b.AMOUNT|img.FILENAME|
|---|---|---|---|---|---|
|<span style="color:blue">1</span>|<span style="color:blue">One</span>|<span style="color:blue">...</span>|<span style="color:blue">1</span>|<span style="color:blue">99.00</span>|<span style="color:blue">foo.jpg</span>|
|1|One|...|1|99.00|<span style="color:blue">bar.jpg</span>|
|1|One|...|1|99.00|<span style="color:blue">baz.jpg</span>|
|1|One|...|<span style="color:blue">2</span>|<span style="color:blue">100.00</span>|foo.jpg|
|1|One|...|2|100.00|bar.jpg|
|1|One|...|2|100.00|baz.jpg|
|1|One|...|<span style="color:blue">3</span>|<span style="color:blue">101.00</span>|foo.jpg|
|1|One|...|3|101.00|bar.jpg|
|1|One|...|3|101.00|baz.jpg|

중복된 데이터들의 리소스 낭비
이 처럼 두 개의 컬렉션을 동시에 조회하려면 개별 쿼리를 사용하는 편이 빠를 수 있다.

### 일괄 데이터 프리페치
```java
@Entity 
public class Item {
  ...
  private User seller;
  ...
}
```
item의 seller에게 username이 있는지 확인하는 루틴일 때,
지연 로딩을 사용하면 Item 인스턴스를 가져오기 위해 하나의 SELECT가 필요하고, Item의 seller 프락시를 초기화 하기 위해 n개의 SELECT가 더 필요하다.
```sql
-- ITEM 조회
SELECT * FROM ITEM WHERE ID = ?
-- 파생된 N개의 SELECT 조회
SELECT * FROM USER WHERE ID = ?
```
하이버네이트는 데이터를 프리페치(미리 가져옴) 할 수 있는 알고리즘을 제공한다.

#### 일괄 페치 
하이버네이트가 하나의 User 프락시를 초기화해야 하는 경우 동일한 SELECT를 사용해 여러 개의 Proxy를 초기화 할 수 있다.
=> ex) User를 로드할 때, 영속성 컨텍스트 내의 초기화 되지 않은 User가 있으면 같이 조회함.
```java
@Entity
// 일괄 페치 사이즈
@org.hibernate.annotations.BatchSize(size = 10)
@Table(name = "USERS")
public class User {
  // ...
}
```



##### Test
```java
List<Item> items = em.createQuery("select i from Item i", Item.class).getResultList();
// select * from ITEM

for (Item item : items) {
  assertNotNull(item.getSeller().getUsername());
  // select * from USERS where ID in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
}
```
일괄 페치는 모든 Proxy와 컬렉션을 초기화 하는 데 필요한 SQL 문의 갯수를 크게 줄일 수 있는 간단하고 최적화된 방법이다.
데이터를 미리 가져와서 더 많은 메모리를 사용할 수 있지만, DB 접근 횟수를 줄이면서 성능상 큰 차이를 만들 수 있다.


#### 서브쿼리를 이용한 컬렉션 프리페치 
```java
@Entity
public class Item {
  @OneToMany(mappedBy = "item")
  // 컬렉션 프리페치를 위한 @Fetch 애너테이션
  @org.hibernate.annotations.Fetch(
    org.hibernate.annotations.FetchMode.SUBSELECT // 서브쿼리 옵션 적용
  )
  private Set<Bid> bids = new HashSet<>();
  // ...
}
```
``@org.hibernate.annotations.Fetch(org.hibernate.annotations.FetchMode.SUBSELECT)`` 로 **bids** 컬렉션을 초기화하는 즉시 Item 인스턴스에 대한 모든 bids 컬렉션을 초기화함.

##### Test
```java
List<Item> items = em.createQuery("select i from Item i", Item.class).getResultList();
// select * from ITEM <- 초기 쿼리 기억

for (Item item : items) {
  assertTrue(item.getBids().size() > 0);
  // select * from BID where ITEM_ID in (
  //  select ID from ITEM <- 초기 쿼리 적용
  // )
}
```

items를 로드하는 데 사용했던 원래 쿼리를 기억한다.
그 다음, 이 초기 쿼리를 서브쿼리에 포함시켜 각 Item에 대한 bids 컬렉션을 조회한다.
> 참고: 하이버네이트는 서브쿼리로 다시 실행되는 원래 쿼리를 특정 영속성 컨텍스트에 대해서만 기억한다.
> 따라서, Item 인스턴스를 준영속 상태로 만든 다음, 새로운 영속성 컨텍스트와 병합하면 프리페치는 발생하지 않는다.

#### 여러 개의 SELECT를 이용한 즉시 페치 
하나의 SQL쿼리와 JOIN을 사용한 페치를 할 때 데카르트의 곱 문제가 발생한다.
이 때 JOIN 연산 대신 하이버네이트가 추가 SELECT 쿼리를 사용해 데이터를 즉시 로드하게 함으로써 결과 집합이 커지고 중복된 SQL 곱이 만들어 지는 것을 방지할 수 있다.

```java
@Entity
public class Item {
    @NotNull
    @ManyToOne(fetch = FetchType.EAGER)
    @org.hibernate.annotations.Fetch(
       org.hibernate.annotations.FetchMode.SELECT // Defaults to JOIN
    )
    private User seller;

    @OneToMany(mappedBy = "item", fetch = FetchType.EAGER)
    @org.hibernate.annotations.Fetch(
       org.hibernate.annotations.FetchMode.SELECT // Defaults to JOIN
    )
    private Set<Bid> bids = new HashSet<>();
}
```
데카르트 곱 문제가 발생할 수 있는 즉시 로딩(EAGER)에서 
``@org.hibernate.annotations.Fetch(org.hibernate.annotations.FetchMode.SELECT)``
옵션으로 추가 SELECT 쿼리를 사용해 SQL 곱이 만들어지는 것을 방지할 수 있다.

```java
  Item item = em.find(Item.class, ITEM_ID);
  // select * from ITEM where ID = ?
  // select * from USERS where ID = ?
  // select * from BID where ITEM_ID = ?

  em.detach(item);

  assertEquals(3, item.getBids().size());
  assertNotNull(item.getBids().iterator().next().getAmount());
  assertEquals("johndoe", item.getSeller().getUsername());
```


#### join fetch를 활용한 동적 즉시 페치 
```java
List<Item> items =
        em.createQuery("select i from Item i join fetch i.seller", Item.class)
                .getResultList();
// select i.*, u.*
//  from ITEM i
//   inner join USERS u on u.ID = i.SELLER_ID
//  where i.ID = ?

em.close(); // Detach all

for (Item item : items) {
  assertNotNull(item.getSeller().getUsername());
}

```

```java
List<Item> items =
        em.createQuery("select i from Item i left join fetch i.bids", Item.class)
                .getResultList();
// select i.*, b.*
//  from ITEM i
//   left outer join BID b on b.ITEM_ID = i.ID
//  where i.ID = ?

em.close(); // Detach all

for (Item item : items) {
  assertTrue(item.getBids().size() > 0);
}
```

### 페치 프로파일
페치 계획과 페치 전력을 결합하여 재사용 가능한 메타데이터 또는 코드로 캡슐화하는 것.
하이버네이트 페치 프로파일은 전역 메타데이터로써 전체 영속성 단위에 선언된다.
package-info.java 파일에서 패키지 수준 메타데이터로 사용하는 것을 권장한다.
```java
@org.hibernate.annotations.FetchProfiles({
  @FetchProfile(name = Item.PROFILE_JOIN_SELLER, // 프로파일 이름 지정
          fetchOverrides = @FetchProfile.FetchOverride( // 프로파일을 재정의할 경우 각각에 대해 하나의 엔티티 연관관계 또는 컬렉션의 이름을 지정해야한다.
                  entity = Item.class,  // 엔티티 지정
                  association = "seller", // 컬렉션의 이름
                  // Join을 통해 프로퍼티를 즉시 조회한다.
                  mode = FetchMode.JOIN
          )
  ),

  @FetchProfile(name = Item.PROFILE_JOIN_BIDS,
          fetchOverrides = @FetchProfile.FetchOverride(
                  entity = Item.class,  // 엔티티 지정
                  association = "bids", // 컬렉션의 이름
                  // Join을 통해 프로퍼티를 즉시 조회한다.
                  mode = FetchMode.JOIN
          )
  )
})

```
위 같이 설정하여 Item이 로드될 때마다 Item#seller와 Item#bids 컬렉션을 Join을 사용해 페치할 수 있다.

#### 앤티티 그래프 활용
엔티티 그래프는 엔티티 노드와 속성을 선언한 것으로, EntityManager#find()를 실행하거나 쿼리 연산에 힌트를 넣을 때 기본 페치 계획을 재정의하거나 보강한다.

```java
@NamedEntityGraphs({
        @NamedEntityGraph, // 기본 EntityGraph 매핑(Item)
        @NamedEntityGraph(
                name = "ItemSeller",
                attributeNodes = {
                        @NamedAttributeNode("seller")
                }
        )
})
@Entity
public class Item {
    @NotNull
    @ManyToOne(fetch = FetchType.LAZY)
    private User seller;
}

```
엔티티 그래프를 활성화 했을 때, Item#seller의 지연 기본 값을 즉시 페치로 변경하는 엔티티 그래프를 작성하고 싶다면,
위와 같이 그래프를 활성화를 할 수 있다.

##### Test

```java
Map<String, Object> properties = new HashMap<>();
properties.put(
  "jakarta.persistence.loadgraph",
  em.getEntityGraph("ItemSeller")
);

Item item = em.find(Item.class, ITEM_ID, properties);
// select i.*, u.*
//  from ITEM i
//   inner join USERS u on u.ID = i.SELLER_ID
// where i.ID = ?

```

```java
@NamedEntityGraphs({
  @NamedEntityGraph(
    name = "BidBidderItem",
    attributeNodes = {
      @NamedAttributeNode(value = "bidder"),
      @NamedAttributeNode(value = "item")
    }
  ),
  @NamedEntityGraph(
          name = "BidBidderItemSellerBids",
          attributeNodes = {
                  @NamedAttributeNode(value = "bidder"),
                  @NamedAttributeNode(
                          value = "item",
                          subgraph = "ItemSellerBids"
                  )
          },
          subgraphs = {
                  @NamedSubgraph(
                          name = "ItemSellerBids",
                          attributeNodes = {
                                  @NamedAttributeNode("seller"),
                                  @NamedAttributeNode("bids")
                          })
          }
  )
})
@Entity
public class Bid {
  // ...
}
```
위 엔티티 그래프를 통해 Bid#bidder, Bid#item, Item#seller와 모든 Item#bids를 즉시 페치하도록 트리거할 수 있다.
